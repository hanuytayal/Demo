{
  "metadata": {
    "problem_name": "find_subarray_sum",
    "timestamp": "20250331_100122",
    "status": "PASSED"
  },
  "problem": {
    "description": "Implement a function called 'find_subarray_sum' that finds a contiguous subarray \nwithin a list of integers that has a given sum. The function should handle the \nfollowing requirements:\n\n1. Input:\n   - nums: A list of integers (positive and negative)\n   - target_sum: The target sum to find\n\n2. Output:\n   - Return a tuple of (start_index, end_index) representing the inclusive range\n     of the subarray that sums to target_sum\n   - If no such subarray exists, return None\n\n3. If multiple solutions exist, return the subarray with:\n   a) Minimum length\n   b) If multiple subarrays have the same minimum length, return the one that \n      starts with the lowest index\n\nExample:\nfind_subarray_sum([1, -3, 2, 4, -2, 3, 1, -2], 5) -> (2, 3)  # [2, 4] sums to 5",
    "analysis": "1. Problem requirements and constraints:\n   - Input parameters and their types: \n     - nums: List[int]\n     - target_sum: int\n   - Output format and type: Tuple[int, int] or None\n   - The function should return a tuple of starting and ending indices of the subarray that sums to the target_sum. If no such subarray exists, it should return None.\n\n2. Key components and their relationships:\n   - The function needs to iterate over the list, maintaining a running sum and checking if it equals the target sum. It also needs to maintain the start and end indices of the current subarray.\n\n3. Error handling and validation requirements:\n   - Required input validation checks: The function should handle an empty list and a target_sum of 0. \n   - Type checking requirements: The function should verify that nums is a list and target_sum is an integer.\n   - Expected exceptions and error conditions: None, given the problem constraints.\n   - Edge cases that must be handled: Negative numbers in the list, multiple valid subarrays, and the entire list summing to the target_sum.\n   - Invalid input scenarios: Non-integer target_sum and non-list nums.\n   - Boundary conditions: The subarray could start at the first index or end at the last index.\n\n4. Implementation considerations:\n   - Suggested approach: Use a sliding window technique to iterate over the list. Maintain a running sum and adjust the start and end of the window as needed to match the target_sum.\n   - Required error handling: Check for valid input types.\n   - Input validation strategy: Before processing, validate that nums is a list and target_sum is an integer.\n   - Type checking approach: Use Python's isinstance function to check input types.\n   - Return type implementation details: The function should return a tuple of two integers or None.\n\n5. Performance requirements:\n   - Time complexity constraints: The function should have a linear runtime, O(n), where n is the length of the list.\n   - Space complexity constraints: The function should have a constant space complexity, O(1), as it only needs to store a few variables.\n   - Memory usage considerations: None, given the problem constraints.\n   - Performance optimization opportunities: None, given the problem constraints.\n\n6. Testing requirements:\n   - Critical test cases: Test the function with lists of varying lengths, including an empty list, and with different target sums.\n   - Error scenarios to test: Inputs of incorrect types.\n   - Edge cases to verify: Lists that have multiple valid subarrays, lists with negative numbers, and lists where the entire list sums to the target_sum.\n   - Performance benchmarks needed: Test the function with a large list to verify its time complexity.\n   - Return type validation tests: Check that the function returns a tuple of two integers or None as required."
  },
  "solution": {
    "code": "from typing import List, Tuple, Optional\ndef find_subarray_with_target_sum(nums: List[int], target_sum: int) -> Optional[Tuple[int, int]]:\n    \"\"\"\n    This function finds a subarray in the given list that sums to the target sum. \n    Args:\n        nums (List[int]): The list of integers.\n        target_sum (int): The target sum.\n    Returns:\n        Tuple[int, int]: The starting and ending indices of the subarray that sums to target_sum.\n        None: If no such subarray exists.\n    Raises:\n        TypeError: If the provided nums is not a list or target_sum is not an integer.\n        ValueError: If the provided nums is an empty list.\n    \"\"\"\n    if not isinstance(nums, list):\n        raise TypeError('nums must be a list')\n    if not all(isinstance(num, int) for num in nums):\n        raise TypeError('All elements in nums must be integers')\n    if not isinstance(target_sum, int):\n        raise TypeError('target_sum must be an integer')\n    if len(nums) == 0:\n        raise ValueError('nums cannot be empty')\n    left, right = 0, 0\n    current_sum = nums[0]\n    while right < len(nums):\n        if current_sum == target_sum:\n            return (left, right)\n        elif current_sum < target_sum:\n            if right + 1 < len(nums):\n                right += 1\n                current_sum += nums[right]\n            else:\n                break\n        else:\n            current_sum -= nums[left]\n            left += 1\n    return None",
    "tests": "def test_find_subarray_with_target_sum():\n    \"\"\"Test suite for find_subarray_with_target_sum function.\"\"\"\n    # Input validation tests\n    def test_type_checking():\n        \"\"\"Test that function correctly handles inputs of incorrect types.\"\"\"\n        with pytest.raises(TypeError, match=\"nums must be a list\"):\n            find_subarray_with_target_sum(\"not a list\", 10)\n        with pytest.raises(TypeError, match=\"target_sum must be an integer\"):\n            find_subarray_with_target_sum([1, 2, 3], \"not an integer\")\n    def test_invalid_input():\n        \"\"\"Test that function correctly handles invalid inputs.\"\"\"\n        with pytest.raises(ValueError, match=\"nums cannot be empty\"):\n            find_subarray_with_target_sum([], 10)\n    def test_boundary_condition():\n        \"\"\"Test that function correctly handles boundary conditions.\"\"\"\n        assert find_subarray_with_target_sum([1], 1) == (0, 0), \"Failed on single element list\"\n    def test_null_empty_input():\n        \"\"\"Test that function correctly handles null/empty inputs.\"\"\"\n        assert find_subarray_with_target_sum([0, 0, 0], 0) == (0, 0), \"Failed on list with zeros\"\n        assert find_subarray_with_target_sum([1, 2, 3], 0) is None, \"Failed on target_sum of zero\"\n    # Error handling tests\n    def test_error_message_validation():\n        \"\"\"Test that function correctly validates error messages.\"\"\"\n        with pytest.raises(TypeError, match=\"nums must be a list\"):\n            find_subarray_with_target_sum(\"not a list\", 10)\n    # Edge case tests\n    def test_minimum_maximum_values():\n        \"\"\"Test that function correctly handles minimum/maximum values.\"\"\"\n        assert find_subarray_with_target_sum([1, 2, 3], 6) == (0, 2), \"Failed on entire list summing to target_sum\"\n        assert find_subarray_with_target_sum([1, 2, 3, 4, 5], 6) == (1, 2), \"Failed on multiple valid subarrays\"\n        assert find_subarray_with_target_sum([-1, 2, 3], 2) == (0, 2), \"Failed on list with negative numbers\"\n    # Functional tests\n    def test_basic_functionality():\n        \"\"\"Test that function correctly handles basic functionality.\"\"\"\n        assert find_subarray_with_target_sum([1, 2, 3], 5) == (1, 2), \"Failed on basic functionality\"\n        assert find_subarray_with_target_sum([5, 3, 1, 7, 6, 4, 2], 10) == (2, 4), \"Failed on complex scenario\"\n    def test_complex_scenarios():\n        \"\"\"Test that function correctly handles complex scenarios.\"\"\"\n        assert find_subarray_with_target_sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 15) == (0, 4), \"Failed on complex scenario\"\n    # Performance tests\n    def test_large_input():\n        \"\"\"Test that function correctly handles large inputs.\"\"\"\n        nums = [1] * 1000000\n        start_time = time.time()\n        assert find_subarray_with_target_sum(nums, 1000000) == (0, 999999), \"Failed on large input\"\n        assert time.time() - start_time < 1, \"Function took too long to execute on large input\""
  },
  "test_results": {
    "success": true,
    "output": "problems/solved/find_subarray_sum_20250331_100122/test_solution.py::test_find_subarray_with_target_sum PASSED [100%]\n\n====================================== 1 passed, 1 warning in 0.11s ======================================="
  }
}