{
  "metadata": {
    "problem_name": "two_sum",
    "timestamp": "20250331_100042",
    "status": "PASSED"
  },
  "problem": {
    "description": "Implement a function called 'two_sum' that finds two numbers in an array that add up to a target value.\n\n1. Input:\n   - nums: A list of integers\n   - target: The target sum to find\n\n2. Output:\n   - Return a list of two indices [i, j] such that nums[i] + nums[j] = target\n   - You may assume that each input has exactly one solution\n   - You may not use the same element twice\n\n3. Constraints:\n   - 2 <= len(nums) <= 10^4\n   - -10^9 <= nums[i] <= 10^9\n   - -10^9 <= target <= 10^9\n\nExample 1:\nInput: nums = [2, 7, 11, 15], target = 9\nOutput: [0, 1]\nExplanation: nums[0] + nums[1] = 2 + 7 = 9\n\nExample 2:\nInput: nums = [3, 2, 4], target = 6\nOutput: [1, 2]\nExplanation: nums[1] + nums[2] = 2 + 4 = 6\n\nExample 3:\nInput: nums = [3, 3], target = 6\nOutput: [0, 1]\nExplanation: nums[0] + nums[1] = 3 + 3 = 6",
    "analysis": "1. Problem requirements and constraints:\n   - We are to implement a function 'two_sum' that takes in an array and a target number as input.\n   - The function should find two numbers in the array that add up to the target number.\n   - The output should be the indices of the two numbers in the array.\n   - Each input is guaranteed to have exactly one solution and we should not use the same element twice.\n   - The length of the input list 'nums' is between 2 and 10^4 inclusive.\n   - The value of each element in 'nums' and 'target' is between -10^9 and 10^9 inclusive.\n\n2. Key components and their relationships:\n   - The main components of this problem are the input list 'nums' and the 'target' value. \n   - The relationship between these components is that two numbers in 'nums' add up to the 'target' value.\n\n3. Error handling and validation requirements:\n   - Required input validation checks:\n     - The input 'nums' must be a list of integers.\n     - The input 'target' must be an integer.\n   - Type checking requirements:\n     - If 'nums' is not a list or 'target' is not an integer, an appropriate error should be raised.\n   - Expected exceptions and error conditions:\n     - The length of 'nums' being less than 2 or greater than 10^4.\n     - The values in 'nums' or 'target' being less than -10^9 or greater than 10^9.\n   - Edge cases that must be handled:\n     - If 'nums' contains only two elements.\n     - If 'nums' contains duplicate elements that add up to 'target'.\n   - Invalid input scenarios:\n     - If 'nums' is an empty list or contains only one element.\n     - If 'nums' or 'target' are not integers.\n   - Boundary conditions:\n     - If the length of 'nums' is exactly 2 or 10^4.\n     - If the values in 'nums' or 'target' are exactly -10^9 or 10^9.\n\n4. Implementation considerations:\n   - Suggested approach:\n     - A hash map can be used to store the difference of 'target' and the current element in 'nums' as the key and the index as the value. While iterating through 'nums', we can check if the current element is present in the hash map. If it is, we have found the two numbers that add up to 'target'.\n   - Required error handling:\n     - Proper error messages should be raised when the input is invalid.\n   - Input validation strategy:\n     - Check the type of 'nums' and 'target' before processing.\n     - Check the length of 'nums' and the value of its elements and 'target'.\n   - Type checking approach:\n     - Use the built-in isinstance() function to check the type of 'nums' and 'target'.\n\n5. Performance requirements:\n   - Time complexity constraints:\n     - The time complexity of the suggested approach is O(n) where n is the length of 'nums'. This is because we are iterating through 'nums' once.\n   - Space complexity constraints:\n     - The space complexity of the suggested approach is also O(n) because in the worst case, we are storing all elements of 'nums' in the hash map.\n   - Memory usage considerations:\n     - Given the constraint that len(nums) <= 10^4, the memory usage of this solution is acceptable.\n   - Performance optimization opportunities:\n     - The suggested approach already has an optimal time and space complexity.\n\n6. Testing requirements:\n   - Critical test cases:\n     - Test with 'nums' containing only two elements.\n     - Test with 'nums' containing multiple elements where two elements add up to 'target'.\n   - Error scenarios to test:\n     - Test with 'nums' being an empty list or containing only one element.\n     - Test with 'nums' or 'target' not being integers.\n   - Edge cases to verify:\n     - Test with 'nums' containing duplicate elements that add up to 'target'.\n     - Test with 'nums' containing negative elements.\n   - Performance benchmarks needed:\n     - Test with 'nums' containing the maximum number of elements (10^4)."
  },
  "solution": {
    "code": "from typing import List\ndef two_sum(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    This function takes in a list of integers 'nums' and an integer 'target'.\n    It finds two numbers in 'nums' that add up to 'target' and returns their indices.\n    It raises an error if 'nums' or 'target' are not of the correct type or out of range.\n    \"\"\"\n    # Input validation\n    if not isinstance(nums, list) or not all(isinstance(num, int) for num in nums):\n        raise TypeError(\"'nums' must be a list of integers\")\n    if not isinstance(target, int):\n        raise TypeError(\"'target' must be an integer\")\n    if len(nums) < 2 or len(nums) > 10**4:\n        raise ValueError(\"'nums' must contain between 2 and 10^4 elements inclusive\")\n    if any(num < -10**9 or num > 10**9 for num in nums) or target < -10**9 or target > 10**9:\n        raise ValueError(\"All elements of 'nums' and 'target' must be between -10**9 and 10**9 inclusive\")\n    # A hash map to store the difference of 'target' and the current element in 'nums' as the key \n    # and the index as the value\n    num_map = {}\n    # Iterate through 'nums'\n    for i, num in enumerate(nums):\n        # If the current element is present in the hash map, we have found the two numbers that add up to 'target'\n        if num in num_map:\n            return [num_map[num], i]\n        else:\n            # Store the difference of 'target' and the current element in 'nums' as the key \n            # and the index as the value in the hash map\n            num_map[target - num] = i\n    # If no two numbers that add up to 'target' are found, raise an error\n    raise ValueError(\"No two numbers in 'nums' add up to 'target'\")",
    "tests": "def test_two_sum():\n    \"\"\"\n    Comprehensive test suite for the 'two_sum' function.\n    \"\"\"\n    # Test with valid input\n    def test_valid_input():\n        assert two_sum([2, 7, 11, 15], 9) == [0, 1], \"Failed on valid input\"\n        assert two_sum([3, 2, 4], 6) == [1, 2], \"Failed on valid input\"\n        assert two_sum([-1, -2, -3, -4, -5], -8) == [2, 4], \"Failed on valid input\"\n    # Test with input of length 2\n    def test_length_two():\n        assert two_sum([1, 2], 3) == [0, 1], \"Failed on input length of two\"\n    # Test with input containing duplicate elements adding up to target\n    def test_with_duplicates():\n        assert two_sum([3, 4, 3], 6) == [0, 2], \"Failed on input with duplicates\"\n    # Test with invalid type of 'nums' or 'target'\n    def test_invalid_type():\n        with pytest.raises(TypeError) as e_info:\n            two_sum(\"invalid\", 9)\n        assert str(e_info.value) == \"'nums' must be a list of integers\"\n        with pytest.raises(TypeError) as e_info:\n            two_sum([2, 7, 11, 15], \"invalid\")\n        assert str(e_info.value) == \"'target' must be an integer\"\n    # Test with 'nums' being an empty list or containing only one element\n    def test_invalid_length():\n        with pytest.raises(ValueError) as e_info:\n            two_sum([], 9)\n        assert str(e_info.value) == \"'nums' must contain at least two elements\"\n        with pytest.raises(ValueError) as e_info:\n            two_sum([1], 9)\n        assert str(e_info.value) == \"'nums' must contain at least two elements\"\n    # Test with 'nums' or 'target' not being integers\n    def test_not_integer():\n        with pytest.raises(TypeError) as e_info:\n            two_sum([1.1, 2.2, 3.3], 4.4)\n        assert str(e_info.value) == \"All elements of 'nums' and 'target' must be integers\"\n    # Test with 'nums' or 'target' being out of range\n    def test_out_of_range():\n        with pytest.raises(ValueError) as e_info:\n            two_sum([10**9+1], 9)\n        assert str(e_info.value) == \"All elements of 'nums' and 'target' must be between -10**9 and 10**9 inclusive\"\n        with pytest.raises(ValueError) as e_info:\n            two_sum([2, 7, 11, 15], 10**9+1)\n        assert str(e_info.value) == \"All elements of 'nums' and 'target' must be between -10**9 and 10**9 inclusive\"\n    # Performance test with 'nums' containing the maximum number of elements (10^4)\n    def test_maximum_elements():\n        start_time = time.time()\n        nums = list(range(1, 10**4+1))\n        target = nums[-1] + nums[-2]\n        assert two_sum(nums, target) == [10**4-2, 10**4-1]\n        execution_time = time.time() - start_time\n        assert execution_time < 1, \"Performance test failed. Execution time must be less than 1 second\""
  },
  "test_results": {
    "success": true,
    "output": "problems/solved/two_sum_20250331_100042/test_solution.py::test_two_sum PASSED                                                                        [100%]\n\n============================================================== 1 passed, 1 warning in 0.06s ==============================================================="
  }
}